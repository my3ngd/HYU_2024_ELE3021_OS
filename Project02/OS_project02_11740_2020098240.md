# Project 1: getgpid() 구현

## xv6 이해하기

### xv6의 형태

xv6는 간단한 운영체제로 볼 수 있다. 우리는 xv6에서 새로운 system call을 정의하고 user program을 작성하여 정의한 system call을 호출할 것이므로, 기존 system call이 어떻게 구현되었는지 확인할 필요가 있다.

- Makefile \
`make`와 `make fs.img` 명령을 통해 OS를 build할 수 있도록 한다. 새로운 파일을 추가하면 변경한다.

- syscall.h \
syscall.h에는 system call들이 번호로 매핑되어 적혀 있다.

- defs.h \
defs.h에는 system call들이 정의되어 있다. 다른 파일에서 system call이 보이도록 한다.

- syscall.c \
실제 시스템 호출 구현에 대한 포인터들이 있다.

- user.h \
user가 사용할 수 있는 system call들이 정의되어 있다.

- usys.S \
xv6의 system call 호출 리스트가 적혀 있다.

이외에도 많은 파일들이 정의되어 있다. 우리는 이를 바탕으로 `project01_getgpid.c` 파일을 추가하고, 여기에서 조부모 프로세스의 pid를 가져오는 `getgpid()`를 구현할 것이다.

### Design

`usys.S` 파일 상단에는 아래와 같은 코드가 있다.
```
#define SYSCALL(name) \
.globl name; \
name: \
    movl $SYS_ ## name, %eax; \
    int $T_SYSCALL; \
    ret
```
해당 코드에 의해 `SYSCALL(name)`을 등록하면 `SYS_{name}` 형태로 변경되어 `syscall.h`에서 매핑한 번호에 매칭된다. 예를 들어 `usys.S` 파일 하단에 `SYSCALL(getgpid)`를 추가하였다면, 이는 `syscall.h`의 `SYS_getgpid`에 매칭되는 것이다.

`syscall.h`에 매칭된 번호는 `syscall.c`에서 사용된다. `syscall.c`의 상단에는
```c
static int (*syscalls[])(void) = {
    [SYS_fork]    sys_fork,
    ...
    [SYS_close]   sys_close,
};
```
이 구현되어 있다. 마지막에 매핑시킨 `[SYS_getgpid] sys_getgpid` 를 추가할 수 있다. 여기서 `sys_getgpid`는 `project01_getgpid.c`에 구현된 wrapper function이다.

요약하면 아래와 같이 설명할 수 있다.
1. user program에서 `user.h`에 정의된 `getgpid()`를 호출한다.
2. 이는 `usys.S`에서 `SYS_getgpid`로 변경된다. 이는 매칭에 사용된다.
3. 여기에 매칭된 번호(여기에서는 22라 하자.)는 `syscall.h`에 정의되어 있으며, `syscall.c`에는 번호에 맞는 system call인 `sys_getgpid()`가 연결되어 있다.
4. 연결된 system call은 우리가 만든 `project01_getgpid.c`에 정의되어 있다.

    이때, 기존 xv6에 없던 system call을 추가하였으므로 기존 함수들과의 구분을 위해 `project01_getgpid.c`라는 별도의 파일에 system call을 작성하였다.
5. `sys_getgpid()`는 wrapper function으로, 같은 파일 내의 `getgpid()`를 호출한다.


## 구현

> 해당 과제는 Windows 11(23H2)의 WSL2(Ubuntu 20.04 LTS) 환경에서 진행되었다.

1. 가장 먼저 `project01_getgpid.c`라는 새로운 파일이 추가될 것이다. 이 파일에서는 조부모 프로세스의 pid를 가져오는 함수 `getgpid()`와 이 함수의 wrapper function인 `sys_getgpid()`가 구현된다. 아래와 같이 구현할 수 있다.
    ```c
    #include "types.h"
    #include "x86.h"
    #include "defs.h"
    #include "date.h"
    #include "param.h"
    #include "memlayout.h"
    #include "mmu.h"
    #include "proc.h"

    // Simple system call
    int
    getgpid(void)
    {
        struct proc* curr_proc = myproc();
        if (curr_proc == 0 || curr_proc->parent == 0 || curr_proc->parent->parent == 0) return 0;  // null handling
        return curr_proc->parent->parent->pid;
    }

    // Wrapper function
    int
    sys_getgpid(void)
    {
        return getgpid();
    }
    ```
    - header 파일들은 `proc.c`와 동일하게 작성하였다.

    `int getgpid()` 함수는 `curr_proc` 포인터에 현재 프로세스를 가져오고 자신, 부모, 조부모 프로세스를 가리키는 포인터가 null pointer(0)인 경우를 처리한다. (실제로는 xv6 부팅 시 2개의 프로세스가 실행되므로 조부모 프로세스가 존재하지만, 예외적인 상황이 발생할 수 있어 0을 반환하도록 하였다.) 그리고 조부모 프로세스를 가리키는 포인터가 null pointer가 아니라면 조부모 프로세스의 pid를 반환한다.

    `int sys_getgpid()` 함수는 `getgpid()` 함수의 wrapper function이다. `getgpid()`의 구현이 단순하므로 wrapper function이 별도로 작업하는 것은 없지만, 이후 구현할 system call에서는 wrapper function을 구현할 때 통일성을 띄우도록 위와 같이 구현하였다.

2. 추가된 파일을 함께 컴파일하기 위해 `Makefile`에 추가한다. `Makefile`에는 다음과 같은 내용을 추가한다. 
    ```
    OBJS = \
        bio.o \
        ...
        project01_getgpid.o\  # <- 추가된 부분
    ```
    이는 `getgpid()`와 `sys_getgpid()`가 추가된 파일의 `.o` 파일을 추가한 것이다. 또한 user program도 함께 컴파일할 것이므로 아래와 같이 수정한다.
    ```
    UPROGS = \
        _cat\
        ...
        _project01\  # <- 추가된 부분
    ```
    ```
    EXTRA=\
        ...
        printf.c umalloc.c project01.c\  # <- 추가된 부분 (마지막의 `project01.c`)
        ...
    ```

3. `defs.h` 파일에 새로 구현한 함수 `getgpid()`를 추가한다.
    ``` c
    ...
    void            clearpteu(pde_t *pgdir, char *uva);
    // project01_getgpid.c
    int             getgpid(void);  // <- 추가된 부분
    ```

4. 이제 구현한 system call을 등록해주어야 한다. `syscall.h`에서 system call의 번호를 매핑해준다. `syscall.c`에서는 `syscall.h`에서 매핑한 번호를 이용해 `syscalls`에 등록한다.
    ``` c
    ...  // syscall.h
    #define SYS_close   21
    #define SYS_getgpid 22  // <- 추가된 부분
    ```
    ``` c
    ...  // syscall.c
    extern int sys_uptime(void);
    extern int sys_getgpid(void);
    ...
    static int (*syscalls[])(void) = {
    ...
    [SYS_close]   sys_close,
    [SYS_getgpid] sys_getgpid,  // <- 추가된 부분
    };
    ```

5. system call을 등록하였으므로, user program에서 사용할 수 있도록 `user.h`에 `getgpid`를 추가한다.
    ``` c
    // system calls
    ...
    int uptime(void);
    int getgpid(void);  // <- 추가된 부분
    ```
6. `usys.S`에 `getgpid()`를 등록한다.
    ```
    ...
    SYSCALL(uptime)
    SYSCALL(getgpid)  <- 추가된 부분
    ```

7. 이제 user program(`project01.c`)을 구현하고 `getgpid()`를 호출하면 된다.
    ``` c
    #include "types.h"
    #include "stat.h"
    #include "user.h"

    int
    main (int argc, char *argv[])
    {
        printf(1, "My student id is 2020098240\n");
        printf(1, "My pid is %d\n", getpid());
        printf(1, "My gpid is %d\n", getgpid());
        exit();
    }
    ```
    user program에서는 system call 호출을 위해 `user.h`을 include하였다. `printf` 내에서 system call인 `getpid`와 `getgpid`를 호출한 모습을 볼 수 있다.

## Result

xv6의 복잡한 실행 명령을 아래와 같이 `bootxv6.sh`에 저장하였다.
```shell
#!/bin/bash
qemu-system-i386 -nographic -serial mon:stdio -hdb fs.img xv6.img -smp 1 -m 512
```

xv6가 있는 디렉토리에서 `make` 명령과 `make fs.img` 명령을 차례로 입력하면 실행할 준비가 완료되었다. 이제 `./bootxv6.sh` 명령을 통해 xv6를 부팅할 수 있다.

실행 후에 제작했던 user program인 `project01`을 입력하면, 프로그램이 실행된다. 결과는 아래와 같이 나온다.
```
My student id is 2020098240
My pid is 3
My gpid is 1
```
즉, 현재 프로세스의 pid는 3이고, gpid는 1이다. 이를 통해 1번 프로세스의 자식 프로세스는 2번이고, 2번 프로세스의 자식 프로세스는 3번임을 추측할 수 있다. 1번과 2번 프로세스는 우리가 명시적으로 실행시키지 않았음에도 존재하는데, xv6 운영체제가 부팅 시에 실행되는 프로세스(boot loader, init process 등)가 있음을 추측할 수 있다.

한 번 더 `project01`을 입력하여 실행하면, 아래와 같이 실행된다.
```
My student id is 2020098240
My pid is 4
My gpid is 1
```
두 번째로 실행한 `project01` 프로세스의 pid는 3이 아닌 4이며, gpid는 3번 프로세스와 동일하게 1번을 가진다. 3번 프로세스는 이미 프로그램의 마지막에 `exit()` 명령을 사용하였으므로 종료되었고, 새로운 `project01` 프로세스는 pid로 3번 대신 4번을 가졌다. 이미 종료된 프로세스의 pid가 회수되지 않았음을 짐작할 수 있다. 이후에도 여러 차례 `project01` 명령을 시행해도 pid만 달라질 뿐 공통된 gpid를 가지는 것을 볼 수 있다.

## Trouble Shooting

System call이 구현된 `project01_getgpid.c` 생성하고 구현한 뒤, `make` 명령을 실행하니 중간에 에러를 발생시키고 더 이상 진행되지 않았다. 임시로 `getgpid()` system call을 다른 system call이 구현된 `proc.c` 파일에 구현하였을 때는 발생하지 않았다. 이에 처음 작성한 `project01_getgpid.c`에서 필요한 header file을 덜 불러와 발생한 문제로 판단하여 `proc.c`와 같은 header file들을 불러와 문제를 해결하였다.
